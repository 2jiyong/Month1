# HEAP메모리

## 요구사항 
HEAP 메모리 구조를 다루는 프로그램이라서 기본 주소에서 상대 주소를 더해서 주소값으로 다루는 포인터 개념을 직접 구현해야 한다.
프로그래밍 요구사항 에 나와있는 함수를 구현한다.

일단은 Heap객체를 만들라고함. 
Heap 객체는 보통 하나를 만든다.
heap 객체 안에서는 heap에게 할당된 총 메모리가 있다.  
그리고 이제 init을 하면 실제로 사용할 수 있는 메모리가 결정되고 base메모리 주소를 반환한다.  
실제로 사용할 메모리는 배열로 구현하고, 한 인덱스가 8바이트를 차지하도록 한다. 

heap에게 할당된 전체 메모리 중에서 init을 하면 크기만큼 할당가능한지 확인하고 절대주소를 반환한다.
init은 사용할 수 있는 메모리 중 가장 작은 부분을 차지한다.  
하지만 어차피 heap 객체 안에서는 절대 주소를 사용하지 않기 때문에 이건 heap 내에서는 필요가 없다.  
heap 객체의 맨 처음에는 heap의 메타데이터가 포함되어야 한다.  
1024 바이트 중 몇 바이트를 차지한다.  메타 데이터에는 힙의 크기가 있다. 
아니면 이건 패스할수도?  

setSize는 단순히 그냥 map으로서 고유한 사이즈를 지정하고, sizemap을 통해 관리한다.  

malloc을 하면 우선 배열을 확보해야한다.
블록에는 우선 메타데이터가 있다. 메타데이터에는 블록의 크기와 할당여부, 현재 블록의 타입이 있다.  
배열을 확보하기 위해 메모리를 읽으면, 우선 메타데이터를 처음 읽게 된다.  
메타데이터를 읽어, 현재 블록이 할당이 가능하다면, 할당을하고, 아니라면 블록의 사이즈만큼 넘어가, 다음 메타데이터로 넘어가게된다.  


블록에는 메타데이터가 포함되어야하기 때문에, 블록의 크기는 8의 배수여야한다.

전체 메모리 배열도 선언.  
1. init
heap에게 할당된 전체 메모리 중에서 init을 하면 크기만큼 할당가능한지 확인하고 절대주소를 반환한다.
맨 처음 init을 하면 heap전체가 하나의 큰 free 블록이 된다. 
2. setSize
setSize는 단순히 그냥 map으로서 고유한 사이즈를 지정하고, sizemap을 통해 관리한다.
추후 전체 heap에 메타데이터를 추가해야한다면 여기에 추가한다.  
heap 전체의 메타데이터를 그냥 객체에 추가하는 것으록 구현한다고 해도 될 듯.
3. malloc  
heap의 시작에서부터 빈칸이 있는지를 확인하고, 빈칸이 있다면 그 빈칸을 할당한다.  
항상 할당한 후, 이후의 메타데이터를 만들어준다.
기존의 블록을 두개로 나눈다고 생각.   
그렇게 하기 위해선 기존의 메타데이터를 기반으로 두번째 메타데이터를 만들어주면 된다.   
4. free
free 를 실행할때는 heap의 메서드를 실행하는게 아니다.  
init에서 base를 설정하고, free는 base를 기반으로, 포인터와 함께 메모리를 해제한다. 


## 메타데이터 양식
1칸은 size,
1칸은 할당여부,
1칸은 타입,
5칸은 padding
    

실수한거 패딩을 생각하고 사이즈를 8로 맞춰줬어야 했는데 그렇게 하지 않았다.  